var _excluded = ["components"];

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React from 'react';
import { mdx } from '@mdx-js/react';
/* @jsxRuntime classic */

/* @jsx mdx */

export var Meta = {
  id: 'euler-problem-001',
  title: 'Solving Euler Problems in F# - 001',
  tags: 'fsharp euler'
};
var layoutProps = {
  Meta: Meta
};
var MDXLayout = "wrapper";
export default function MDXContent(_ref) {
  var components = _ref.components,
      props = _objectWithoutProperties(_ref, _excluded);

  return mdx(MDXLayout, _extends({}, layoutProps, props, {
    components: components,
    mdxType: "MDXLayout"
  }), mdx("p", null, "In my quest to master everything there is to know about functional programming and F#, today I start working through the \"Euler Problems\""), mdx("p", null, "The first problem is pretty basic, so I won't talk to much on it, but the problem we're trying to solve:"), mdx("blockquote", null, mdx("p", {
    parentName: "blockquote"
  }, "If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\nFind the sum of all the multiples of 3 or 5 below 1000.")), mdx("p", null, "This kind of problem is exactly what functional languages are designed to solve, and in a very basic one liner, we have our F# solution:"), mdx("pre", null, mdx("code", {
    parentName: "pre"
  }, "let answer = [1..999] |> Seq.where(fun x -> x % 3 = 0 || x % 5 = 0) |> Seq.sum\n")));
}
;
MDXContent.isMDXComponent = true;