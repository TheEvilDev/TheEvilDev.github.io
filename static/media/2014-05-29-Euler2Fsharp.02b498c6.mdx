var _excluded = ["components"];

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React from 'react';
import { mdx } from '@mdx-js/react';
/* @jsxRuntime classic */

/* @jsx mdx */

export var Meta = {
  id: 'euler-problem-002',
  title: 'Solving Euler Problems in F# - 002 - Even Fibonacci numbers',
  tags: 'fsharp euler'
};
var layoutProps = {
  Meta: Meta
};
var MDXLayout = "wrapper";
export default function MDXContent(_ref) {
  var components = _ref.components,
      props = _objectWithoutProperties(_ref, _excluded);

  return mdx(MDXLayout, _extends({}, layoutProps, props, {
    components: components,
    mdxType: "MDXLayout"
  }), mdx("p", null, "Continuing on my series of solving the Euler problems in F#, here's the next one:"), mdx("blockquote", null, mdx("p", {
    parentName: "blockquote"
  }, "Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:"), mdx("p", {
    parentName: "blockquote"
  }, "1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ..."), mdx("p", {
    parentName: "blockquote"
  }, "By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.")), mdx("p", null, "Again, like the first problem, we can leverage the power of F# Sequences to make this problem trivial. I learned something new with this particular problem, and using unfold to create an infinite fibinocci sequence is pretty awesome:"), mdx("pre", null, mdx("code", {
    parentName: "pre"
  }, "let answer = Seq.unfold (fun (a,b) -> Some( a+b, (b, a+b) ) ) (0,1) \n                |> Seq.takeWhile(fun x -> x <= 4000000)\n                |> Seq.where(fun x -> x % 2 = 0)\n                |> Seq.sum\n")), mdx("p", null, "Pretty straight forward, create a fibinacci sequence, collect while the number is less than or equal to 4 million, filter out only the even numbers, and then total them all up."));
}
;
MDXContent.isMDXComponent = true;